using Triangulate
using Grid
using Quadrature
using ExtendableSparse
using LinearAlgebra
using SparseArrays
using FiniteElements
using FESolveCommon
using FESolveStokes
using FESolvePoisson
using ForwardDiff
ENV["MPLBACKEND"]="tkagg"
using PyPlot
using Printf


function triangulate_unitsquare(maxarea)
    triin=Triangulate.TriangulateIO()
    triin.pointlist=Matrix{Cdouble}([0 0; 1 0; 1 1; 0 1]');
    triin.segmentlist=Matrix{Cint}([1 2 ; 2 3 ; 3 4 ; 4 1 ]')
    triin.segmentmarkerlist=Vector{Int32}([1, 2, 3, 4])
    (triout, vorout)=triangulate("pQa$(@sprintf("%.16f", maxarea))", triin)
    return Grid.Mesh{Float64}(Array{Float64,2}(triout.pointlist'),Array{Int64,2}(triout.trianglelist'),Grid.ElemType2DTriangle());
end


function main()

#fem = "BR"
fem = "CR"

#use_problem = "P7vortex"; u_order = 7; error_order = 6; p_order = 3; f_order = 5;
#use_problem = "constant"; u_order = 0; error_order = 0; p_order = 0; f_order = 0;
#use_problem = "linear"; u_order = 1; error_order = 2; p_order = 0; f_order = 0;
#use_problem = "quadratic"; u_order = 2; error_order = 2; p_order = 1; f_order = 0;
use_problem = "cubic"; u_order = 3; error_order = 4; p_order = 2; f_order = 1;
maxlevel = 4
nu = [1,1e-2,1e-4]

show_convergence_history = true


# define problem data
function theta(problem) # stream function
    function closure(x)
        if problem == "linear"
            return - x[2]^2 * 1//2;
        elseif problem == "P7vortex"
            return x[1]^2 * (x[1] - 1)^2 * x[2]^2 * (x[2] - 1)^2
        elseif problem == "quadratic"
            return x[1]^3+x[2]^3;
        elseif problem == "cubic"
            return x[1]^4+x[2]^4;  
        elseif problem == "constant"
            return x[1] + x[2];    
        end
    end    
end    


function exact_pressure(problem) # exact pressure
    function closure(x)
        if problem == "P7vortex"
            return x[1]^3 + x[2]^3 - 1//2 
        elseif problem == "quadratic"
            return x[1] - 1//2;    
        elseif problem == "cubic"
            return x[1]^2 + x[2]^2 - 2//3;    
        else
            return 0;    
        end
    end    
end


function volume_data!(problem, nu)
    function closure(result,x)
        result[1] = 0.0;
        result[2] = 0.0;
        if problem == "P7vortex"
            result[1] = nu*(4*(2*x[2]-1)*(3*x[1]^4-6*x[1]^3+6*x[1]^2*x[2]^2 - 6*x[1]^2*x[2] + 3*x[1]^2 -6*x[1]*x[2]^2 + 6*x[1]*x[2] + x[2]^2 - x[2]))
            result[2] = -nu*(4*(2*x[1]-1)*(3*x[2]^4-6*x[2]^3+6*x[2]^2*x[1]^2 - 6*x[2]^2*x[1] + 3*x[2]^2 -6*x[2]*x[1]^2 + 6*x[2]*x[1] + x[1]^2 - x[1]))
            result[1] += 3*x[1]^2
            result[2] += 3*x[2]^2   
        elseif problem == "quadratic"
            result[1] = 6.0*nu
            result[2] = -6.0*nu
            result[1] += 1.0
        elseif problem == "cubic"
            result[1] = 24.0*nu*x[2]
            result[2] = -24.0*nu*x[1]
            result[1] += 2*x[1]
            result[2] += 2*x[2]
        end
    end    
end


function exact_velocity!(problem) # velocity (= curl(theta), generated by FowardDiff)
    
    function closure(result,x)
        result[1] = 0.0;
        result[2] = 0.0;
        if problem == "P7vortex"
            result[1] = -2.0*(1.0-x[1])^2*x[1]^2*(1.0-x[2])^2*x[2]
            result[1] += 2.0*(1.0-x[1])^2*x[1]^2*(1.0-x[2])*x[2]^2
            result[2] = 2.0*(1.0-x[2])^2*x[2]^2*(1.0-x[1])^2*x[1]
            result[2] -= 2.0*(1.0-x[2])^2*x[2]^2*(1.0-x[1])*x[1]^2
        elseif problem == "constant"
            result[1] = -1.0
            result[2] = 1.0
        elseif problem == "linear"
            result[1] = x[2]
            result[2] = 0.0
        elseif problem == "quadratic"
            result[1] = -3*x[2]^2
            result[2] = 3*x[1]^2
        elseif problem == "cubic"
            result[1] = -4.0*x[2]^3
            result[2] = 4.0*x[1]^3
        end
    end 
    
end


# write data into problem description structure
PD = FESolveStokes.StokesProblemDescription()
PD.name = use_problem;
PD.viscosity = 1;
PD.volumedata4region = Vector{Function}(undef,1)
PD.boundarydata4bregion = Vector{Function}(undef,1)
PD.boundarytype4bregion = [1]
PD.quadorder4region = [f_order]
PD.boundarydata4bregion[1] = exact_velocity!(use_problem)
PD.quadorder4bregion = [u_order]
FESolveStokes.show(PD);

function wrap_pressure(result,x)
    result[1] = exact_pressure(use_problem)(x)
end    

L2error_velocity = zeros(Float64,length(nu),maxlevel)
L2error_velocity_reconst = zeros(Float64,length(nu),maxlevel)
L2error_velocity_reconst2 = zeros(Float64,length(nu),maxlevel)

ndofs = zeros(Int,maxlevel)

for level = 1 : maxlevel

println("Solving Stokes problem on refinement level...", level);
println("Generating grid by triangle...");
maxarea = 4.0^(-level)
grid = triangulate_unitsquare(maxarea)
Grid.show(grid)

# load finite element
if fem == "BR"
    # Bernardi--Raugel with RT0/BDM1 reconstruction
    FE_velocity = FiniteElements.getBRFiniteElement(grid,2);
    FE_pressure = FiniteElements.getP0FiniteElement(grid,1);
elseif fem == "CR"
    # Crouzeix--Raviart with RT0/BDM1 reconstruction
    FE_velocity = FiniteElements.getCRFiniteElement(grid,2,2);
    FE_pressure = FiniteElements.getP0FiniteElement(grid,1);
end    
FiniteElements.show(FE_velocity)
FiniteElements.show(FE_pressure)
ndofs_velocity = FiniteElements.get_ndofs(FE_velocity);
ndofs_pressure = FiniteElements.get_ndofs(FE_pressure);
ndofs[level] = ndofs_velocity + ndofs_pressure;

for nu_index = 1 : length(nu)
    # solve Stokes problem
    PD.viscosity = nu[nu_index];
    PD.volumedata4region[1] = volume_data!(use_problem, nu[nu_index])
    val4dofs = zeros(Base.eltype(grid.coords4nodes),ndofs[level]);

    residual = solveStokesProblem!(val4dofs,PD,FE_velocity,FE_pressure, 0);
    val4dofs_reconst = zeros(Base.eltype(grid.coords4nodes),ndofs[level]);
    residual = solveStokesProblem!(val4dofs_reconst,PD,FE_velocity,FE_pressure, 1);
    val4dofs_reconst2 = zeros(Base.eltype(grid.coords4nodes),ndofs[level]);
    residual = solveStokesProblem!(val4dofs_reconst2,PD,FE_velocity,FE_pressure, 2);
    
    # compute errors
    integral4cells = zeros(size(grid.nodes4cells,1),2);
    integrate!(integral4cells,eval_L2_interpolation_error!(exact_velocity!(use_problem), val4dofs[1:ndofs_velocity], FE_velocity), grid, error_order, 2);
    L2error_velocity[nu_index,level] = sqrt(abs(sum(integral4cells[:])));
    integrate!(integral4cells,eval_L2_interpolation_error!(exact_velocity!(use_problem), val4dofs_reconst[1:ndofs_velocity], FE_velocity), grid, error_order, 2);
    L2error_velocity_reconst[nu_index,level] = sqrt(abs(sum(integral4cells[:])));
    integrate!(integral4cells,eval_L2_interpolation_error!(exact_velocity!(use_problem), val4dofs_reconst2[1:ndofs_velocity], FE_velocity), grid, error_order, 2);
    L2error_velocity_reconst2[nu_index,level] = sqrt(abs(sum(integral4cells[:])));
 
end # loop over nu
end # loop over levels

println("\n L2 velocity error vanilla");
show(L2error_velocity)
println("\n L2 velocity error RT reconstruction");
show(L2error_velocity_reconst)
println("\n L2 velocity error BDM reconstruction");
show(L2error_velocity_reconst2)

if (show_convergence_history)
    for nu_index = 1 : length(nu)
        PyPlot.figure(nu_index)
        PyPlot.loglog(ndofs,L2error_velocity[nu_index,:],"-o")
        PyPlot.loglog(ndofs,L2error_velocity_reconst[nu_index,:],"-o")
        PyPlot.loglog(ndofs,L2error_velocity_reconst2[nu_index,:],"-o")
        PyPlot.loglog(ndofs,ndofs.^(-1/2),"--",color = "gray")
        PyPlot.loglog(ndofs,ndofs.^(-1),"--",color = "gray")
        PyPlot.loglog(ndofs,ndofs.^(-3/2),"--",color = "gray")
        PyPlot.legend(("L2 error velocity " * fem,"L2 error velocity " * fem * " (RT reconstruction)","L2 error velocity " * fem * " (BDM reconstruction)","O(h)","O(h^2)","O(h^3)"))
        PyPlot.title("Convergence history (fem=" * fem * " nu=" * string(nu[nu_index]) * " problem=" * use_problem * ")")
        ax = PyPlot.gca()
        ax.grid(true)
    end    
end    

    
end


main()
