using Triangulate
using Grid
using Quadrature
using ExtendableSparse
using LinearAlgebra
using SparseArrays
using FiniteElements
using FESolveCommon
using FESolveStokes
using FESolvePoisson
using ForwardDiff
ENV["MPLBACKEND"]="tkagg"
using PyPlot
using Printf


function triangulate_unitsquare(maxarea)
    triin=Triangulate.TriangulateIO()
    triin.pointlist=Matrix{Cdouble}([0 0; 1 0; 1 1; 0 1]');
    triin.segmentlist=Matrix{Cint}([1 2 ; 2 3 ; 3 4 ; 4 1 ]')
    triin.segmentmarkerlist=Vector{Int32}([1, 2, 3, 4])
    (triout, vorout)=triangulate("pQa$(@sprintf("%.16f", maxarea))", triin)
    return Grid.Mesh{Float64}(Array{Float64,2}(triout.pointlist'),Array{Int64,2}(triout.trianglelist'),Grid.ElemType2DTriangle());
end


function main()

#fem = "RT0"
#fem = "RT1"
fem = "BDM1"


use_problem = "P7vortex"; u_order = 7; error_order = 6; 
#use_problem = "constant"; u_order = 0; error_order = 0; 
#use_problem = "linear"; u_order = 1; error_order = 2; 
#use_problem = "quadratic"; u_order = 2; error_order = 4; 
#use_problem = "cubic"; u_order = 3; error_order = 6;
maxlevel = 5

show_plots = true
show_convergence_history = true

function exact_velocity!(problem) # velocity (= curl(theta), generated by FowardDiff)
    
    function closure(result,x)
        result[1] = 0.0;
        result[2] = 0.0;
        if problem == "P7vortex"
            result[1] = -2.0*(1.0-x[1])^2*x[1]^2*(1.0-x[2])^2*x[2]
            result[1] += 2.0*(1.0-x[1])^2*x[1]^2*(1.0-x[2])*x[2]^2
            result[2] = 2.0*(1.0-x[2])^2*x[2]^2*(1.0-x[1])^2*x[1]
            result[2] -= 2.0*(1.0-x[2])^2*x[2]^2*(1.0-x[1])*x[1]^2
        elseif problem == "constant"
            result[1] = -1.0
            result[2] = 1.0
        elseif problem == "linear"
            result[1] = x[2]
            result[2] = 0.0
        elseif problem == "quadratic"
            result[1] = -3*x[2]^2
            result[2] = 3*x[1]^2
        elseif problem == "cubic"
            result[1] = -4.0*x[2]^3
            result[2] = 4.0*x[1]^3
        end
    end 
    
end


L2error_velocity = zeros(Float64,maxlevel)
ndofs = zeros(Int,maxlevel)

for level = 1 : maxlevel

println("Solving Hdiv best approximation problem on refinement level...", level);
println("Generating grid by triangle...");
maxarea = 4.0^(-level)
grid = triangulate_unitsquare(maxarea)
Grid.show(grid)

# load finite element
if fem == "RT0"
    # Raviart-Thomas 0
    FE = FiniteElements.getRT0FiniteElement(grid);
elseif fem == "RT1"
    # Raviart-Thomas 1
    FE = FiniteElements.getRT1FiniteElement(grid);
elseif fem == "BDM1"
    # Brezzi-Douglas-Marini 1
    FE = FiniteElements.getBDM1FiniteElement(grid);
end    
FiniteElements.show(FE)
ndofs[level] = FiniteElements.get_ndofs(FE);

# compute Hdiv best-approximation
val4dofs = FiniteElements.createFEVector(FE);
computeBestApproximation!(val4dofs,"L2",exact_velocity!(use_problem),exact_velocity!(use_problem),FE,u_order + FiniteElements.get_polynomial_order(FE))

# compute error of Hdiv best-approximation
integral4cells = zeros(size(grid.nodes4cells,1),2);
integrate!(integral4cells,eval_L2_interpolation_error!(exact_velocity!(use_problem), val4dofs, FE), grid, error_order, 2);
L2error_velocity[level] = sqrt(abs(sum(integral4cells[:])));

if (show_plots) && (level == maxlevel) && ndofs[level] < 7500
    pygui(true)
    
    # evaluate velocity and pressure at grid points
    velo = FESolveCommon.eval_at_nodes(val4dofs,FE);
    
    PyPlot.figure(1)
    PyPlot.plot_trisurf(view(grid.coords4nodes,:,1),view(grid.coords4nodes,:,2),view(velo,:,1),cmap=get_cmap("ocean"))
    PyPlot.title("component 1")
    PyPlot.figure(2)
    PyPlot.plot_trisurf(view(grid.coords4nodes,:,1),view(grid.coords4nodes,:,2),view(velo,:,2),cmap=get_cmap("ocean"))
    PyPlot.title("component 2")
    show()
end

end # loop over levels

    println("\n L2 velocity RT error");
    show(L2error_velocity)

if (show_convergence_history)
    PyPlot.figure()
    PyPlot.loglog(ndofs,L2error_velocity,"-o")
    PyPlot.loglog(ndofs,ndofs.^(-1/2),"--",color = "gray")
    PyPlot.loglog(ndofs,ndofs.^(-1),"--",color = "gray")
    PyPlot.loglog(ndofs,ndofs.^(-3/2),"--",color = "gray")
    PyPlot.legend(("L2 error","O(h)","O(h^2)","O(h^3)"))
    PyPlot.title("Convergence history (fem=" * fem * " problem=" * use_problem * ")")
    ax = PyPlot.gca()
    ax.grid(true)
end    

    
end


main()
